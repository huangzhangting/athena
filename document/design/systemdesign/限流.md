
#### 1、与用户打交道的服务
比如web服务、对外API，这种类型的服务有以下几种可能导致机器被拖垮：
用户增长过快（这是好事）
因为某个热点事件（微博热搜）
竞争对象爬虫
恶意的刷单

#### 2、对内的RPC服务
一个服务A的接口可能被BCDE多个服务进行调用，在B服务发生突发流量时，直接把A服务给调用挂了，导致A服务对CDE也无法提供服务。
这种情况时有发生，解决方案有两种：
  1、每个调用方采用线程池进行资源隔离
  2、使用限流手段对每个调用方进行限流


### 常用限流算法：
1、计数器算法：单位时间内限制请求数量，
会有“突刺现象”，短时间内直接把请求数占满了，后面的请求就全拒绝了

2、漏桶算法：固定容量、固定处理速度
可以准备一个队列，用来保存请求，另外通过一个线程池定期从队列中获取请求并执行，可以一次性获取多个并发执行。
这种算法，在使用过后也存在弊端：无法应对短时间的突发流量。

3、令牌桶算法
可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，
每来一个请求，就从队列中获取一个令牌，并继续执行
开源组件：Guava RateLimiter

#### 令牌桶算法VS漏桶算法
漏桶
漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。

令牌桶
生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。
这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，
而且拿令牌的过程并不是消耗很大的事情。


### 分布式限流：
可以利用redis incr命令

