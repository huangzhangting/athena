
### 建立索引需要考虑哪些因素？
1）索引字段是否常用于查询
2）联合索引，需要考虑索引字段顺序
3）索引字段选择，需要考虑字段值的区分度
4）防止索引过多

### 数据库三范式
1）表的每列不可再拆分：常见的会有json串大字段
2）非主键列完全依赖于主键，不能依赖于部分主键：
  场景：业务主键是联合多个字段，并且冗余的一些字段，其中部分冗余的依赖于联合主键中的某一个字段
3）非主键列只能依赖于主键，不能依赖于其他非主键列：
  场景：订单表中有客户id，并且冗余了客户其他信息

但是一般情况下，为了提高查询效率，经常会冗余一些字段，会破坏第二、第三范式


### 查询字段数量对性能的影响
在全表扫描流程中字段的多少到底有哪些异同点：

不同点：
构建的read_set 不同，字段越多read_set中为‘1’的位数越多
建立的模板不同，字段越多模板数量越多
每行数据转换为MySQL格式的时候不同，字段越多模板越多，那么循环转换每个字段的循环次数也就越多，并且这是每行都要处理的。
返回给MySQL层的行内存消耗越大

相同点：
访问的行数一致
访问的流程一致
where过滤的方式一致

在整个不同点中，我认为最耗时的部分应该是每行数据转换为MySQL格式的消耗最大

### mysql怎么解决幻读？
RR隔离级别，“当前读” 情况下，利用行锁+间隙锁机制，避免幻读


### 分页查询优化
大分页查询为什么慢： order by col limit offset, N
MySQL执行取offset+N行数据，然后放弃offset行，返回N行。
随着扫描的记录数越多，SQL的性能就会越差，
因为N的值越大，MySQL需要扫描越多的数据来定位到具体的N行，这样耗费大量的 IO 成本和时间成本

1）应用系统使用缓存，利用搜索引擎技术等
2）利用子查询分页查询主键（这里可以利用到覆盖索引），然后关联查询数据
select a.* from 表 a, (select id from 表 where 条件 limit offset,N) b 
where a.id=b.id

### MVCC原理
表隐藏字段，
trx_id: 这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。
roll_pointer: 
每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。
这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，
通过它来获得上一个版本的记录信息。

undo日志存着版本链

已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,
而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。

ReadView 列表中存放当前事务id

### 慢sql分析
1）是否用到索引，能否通过索引来解决
2）是否查询多余的数据，比如大分页，select * 
3）表数据是否过多，分表


### 所以InnoDB中，B+树组织及查询数据总结起来，主要有以下两点:
1）页可以用来存放记录，也可以用来存放键值+指针，所有记录的节点按照大小顺序存放在同一层叶子节点中，
非叶子节点用来存放键值+指针，键值一般是页面中的最小值(Low Key);
2）索引组织表只能通过非叶子节点的二分查找法以及指针确定数据在哪个页中，
然后通过把查找到的页读入内存后，再在内存中进行查找记录行。

### 为什么B+树比B树更适合做索引
 B树也是多叉树结构，一种自平衡的树，而且B+树是从B树演化而来的，那么为什么不使用B+树的前身B树呢？
从结构比较来看，B树相比B+树的一个主要区别就在于B树的分支节点上存储着数据，
而B+树的分支节点只是叶子节点的索引而已。根据这个差别可以得出以下结论：

1）磁盘IO读写次数相比B树降低了
  在B+树中，其非叶子的内部节点都变成了key值，因此其内部节点相对B 树更小。
如果把所有同一内部节点的key存放在同一盘块中，那么盘块所能容纳的key数量也越多。
一次性读内存中的需要查找的key值也就越多。相对来说IO读写次数也就降低了。

2）每次查询的时间复杂度是固定的
  在B+树中，由于分支节点只是叶子节点的索引，所以对于任意关键字的查找都必须从根节点走到分支节点，
所有关键字查询路径长度相同，每次查询的时间复杂度是固定的。
但是在B树中，其分支节点上也保存有数据，对于每一个数据的查询所走的路径长度是不一样的，所以查询效率也不一样。

3）遍历效率更高
  由于B+树的数据都存储在叶子节点上，分支节点均为索引，方便扫库，只需扫一遍叶子即可。
但是B树在分支节点上都保存着数据，要找到具体的顺序数据，需要执行一次中序遍历来查找。
所以B+树更加适合范围查询的情况，在解决磁盘IO性能的同时解决了B树元素遍历效率低下的问题。

### B+树作为索引可以存放多少数据
 有道面试题，问InnoDB中，一颗的B+树可以存放多少行数据？
那么我们该如何计算呢？假设我们定义一颗B+树高度为2，即一个根节点和若干叶子节点。

那么这课B+树的存放总行记录数=根节点指针数*单个叶子记录的行数。

这里先计算叶子节点，B+树中的单个叶子节点的大小为16K，假设每一条目为1K，
那么记录数即为16(16k/1K=16)，
然后计算非叶子节点能够存放多少个指针，假设主键ID为bigint类型，那么长度为8字节，
而指针大小在InnoDB中是设置为6个字节，这样加起来一共是14个字节。
那么通过页大小/(主键ID大小+指针大小），即16384/14=1170个指针，
所以一颗高度为2的B+树能存放18720条这样的记录。
根据这个原理就可以算出一颗高度为3的B+树可以存放1170*1170*16=21902400条记录。
所以在InnoDB中B+树高度一般为2-3层，它就能满足千万级的数据存储。


### 锁
表锁、页锁、行锁
表锁：意向锁：排他意向锁、共享意向锁

行锁：依赖于索引，索引列才能加锁
    排他锁：SELECT * FROM table_name WHERE ... FOR UPDATE
    共享锁：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
    
排他锁：记录锁、间隙锁、Next-key锁（记录锁+间隙锁）

间隙锁：触发条件：
1）非主键 && 非唯一索引 加排它锁时，触发间隙锁
2）主键 || 唯一索引，加排它锁时，条件记录不存在，触发间隙锁

间隙锁的范围：锁的是间隙区域，不仅仅是索引字段值区间

间隙锁目的：解决幻读问题

