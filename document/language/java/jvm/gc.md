## 判断对象存活
##### 1、引用计数算法：给对象中添加一个引用计数器
弊端：循环引用问题

##### 2、可达性分析算法：
以一些列的“GC Roots”对象作为起始点，建立引用链，当一个对象到GC Roots不可达时，则判定该对象可以回收。

##### 哪些对象可以作为 GC Roots：
1）虚拟机栈中的引用对象
2）方法区中类静态属性引用对象
3）方法区中常量引用对象
4）本地方法栈中的引用对象

## 垃圾回收算法
##### 1、标记-清除算法
弊端：
1）标记、清除两个过程效率都不高
2）清理完后，会产生大量不连续的内存碎片，
如果这时创建大对象，就有可能没有足够的连续内存空间，需要再次触发垃圾回收
##### 2、复制算法：
将内存分成两块，每次只使用其中一块，垃圾回收时，把存活的对象复制到另一块内存

弊端：
浪费内存空间

##### 3、标记-整理算法
回收对象时，将存活的对象向一端移动，然后再清理可回收对象

##### 4、分代收集算法
java堆分为新生代和老年代，各个年代使用不同的回收算法，
在新生代中，发生gc后，只有少量对象存活，可以使用复制算法


##### 什么是空间分配担保策略？
JVM在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，
如果大于，则此次Minor GC是安全的
如果小于，则虚拟机会查看HandlePromotionFailure设置项的值是否允许担保失败。
如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，
如果大于则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。


