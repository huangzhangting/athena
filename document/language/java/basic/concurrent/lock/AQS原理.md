## AbstractQueuedSynchronizer 原理

#### 同步队列

#### 队列节点状态：
CANCELLED =  1
SIGNAL    = -1
CONDITION = -2
PROPAGATE = -3
0：默认值


#### 独占模式
获取锁：
1、尝试获取锁，由子类实现
2、获取锁失败，加入同步队列
3、申请排队：for(;;)循环体
 1）如果前置节点是头节点，就尝试获取锁：获取锁成功，就设置当前节点为同步队列头结点
 2）否则，将前置节点的状态设置为 SIGNAL（需要唤醒后面的节点），当前线程进入等待
  
释放锁：
1、尝试释放锁，由子类实现
2、释放锁成功，头结点状态设置为0，唤醒后继waitStatus<0的节点的线程
3、后继节点从等待状态返回，从新尝试获取锁

#### 独占锁实例
1、ReentrantLock
 公平锁：锁没被占用时，有前置节点，就直接入队列等待
 非公平：锁没被占用时，cas修改锁状态
 

#### 共享模式
获取锁
1、尝试获取锁，由子类实现，返回值>=0，就表示获取共享锁成功
2、获取失败，创建共享模式节点，加入同步队列，
开始排队：for (;;)循环体
1）跟独占锁的区别：获取锁成功，会继续释放锁，唤醒后面的节点
（因为获取锁的逻辑跟独占是一样的，所以需要自动唤醒后继节点，实现共享的逻辑）

释放锁
1、尝试释放锁，由子类实现
2、释放成功后，如果有后继节点需要唤醒，则唤醒后继节点

#### 共享模式的实例
1、Semaphore 信号量
2、CountDownLatch 


#### 等待队列
ConditionObject implements Condition 里面会维护等待队列
在锁的下面，支持实现更精细化的控制，多个条件控制

等待
1、线程调用condition.await()方法，将当前线程包装成(CONDITION状态)节点，加入到等待队列
2、释放锁release()方法，唤醒后继节点
3、线程进入等待状态：LockSupport.park(this);
当别的线程调用了signal（），并且是当前线程被唤醒的时候才从park()方法返回
4、当被唤醒后，该线程会尝试去获取锁，acquireQueued()

唤醒
1、线程调用condition.signal()方法，
先会判断当前线程是不是独占的持有锁，然后唤醒等待队列中的第一个等待线程
2、将等待队列中的头节点移除，CAS修改节点的状态（确保未被取消），修改成功后，加到同步队列
3、唤醒刚加入到同步队列的线程，被唤醒之后，该线程才能从await()方法的park()中返回

