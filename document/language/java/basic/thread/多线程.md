### 多线程有什么作用？
1）发挥多核CPU优势
2）防止阻塞：一个线程占用一段CPU时间

### 实现多线程的三中方式
1）业务类继承Thread类：因为java是单继承，所以不利于扩展
2）业务类实现Runnable接口
3）业务类实现Callable接口：
通过 FutureTask 包装callable，本质上是FutureTask本身实现了Runnable接口，
这个实现方式的好处是可以在主程序中通过FutureTask.get()方法拿到异步的结果

### Runnable接口和Callable接口的区别
实现Runnable接口，业务代码只是纯粹的执行run方法，
实现Callable接口，执行的call方法，是有返回值的，可以配合FutureTask.get()方法拿到异步的结果

### CyclicBarrier 使用
CyclicBarrier是一个同步辅助类，它允许 一组线程相互等待 直到所有线程都到达一个公共的屏障点。
在程序中有固定数量的线程，这些线程有时候必须等待彼此，这种情况下，使用CyclicBarrier很有帮助。
这个屏障之所以用循环修饰，是因为在所有的线程释放彼此之后，这个屏障是 可以重新使用的。

CyclicBarrier常用于多线程分组计算。

构造参数中可以传相互等待的线程数量以及屏障线程：
屏障线程的运行时机：等待的线程数量=parties之后，CyclicBarrier打开屏障之前。
举例：在分组计算中，每个线程负责一部分计算，最终这些线程计算结束之后，交由屏障线程进行汇总计算。

### CountDownLatch 使用
1）子线程可以等待主线程，发送信号，然后子线程一起开始执行，子线程执行完，自己就结束了
2）主线程等待所有子线程全部完成，主线程才结束

### volatile作用，原理


### 什么是线程安全
代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。

### 获取到线程dump文件
1、获得线程id，jps命令，在Linux环境下还可以使用 ps -ef | grep java
2、打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid

### Thread.sleep(m)
当前线程让出CPU，在将来的参数时间内，不参与CPU竞争
如果是在同步代码内，不会释放已获得的锁

### Object.wait(m)
要先持有对象的锁，才能调用对象的wait方法，调用后当前线程让出CPU，并且会释放对象的锁；
一般情况都会有配套的其他线程notify通知；

### 生产者消费者模型的作用
1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率
2）解耦，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约

### ThreadLocal作用，原理


### 线程池作用
避免频繁地创建和销毁线程，达到线程对象的重用。
另外，使用线程池还可以根据项目灵活地控制并发的数目。

### 如果你提交任务时，线程池队列已满，这时会发生什么
1）如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，
因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务
2）如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，
ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，
如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，
那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy

### Java中用到的线程调度方式
抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

### AQS

### CAS

### 内存模型

### 单例模式

### Semaphore 使用


### 高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？
1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换

2）并发不高、任务执行时间长的业务要区分开看：
 a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务
 b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换

3）并发高、业务执行时间长，
解决这种类型任务的关键不在于线程池而在于整体架构的设计，
看看这些业务里面某些数据是否能做缓存是第一步，
增加服务器是第二步，
至于线程池的设置，设置参考（2）。

最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。

